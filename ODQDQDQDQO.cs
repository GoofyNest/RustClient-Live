public class ODQDQDQDQO : MonoBehaviour // TypeDefIndex: 7177
{	// Methods

	// RVA: 0xBFD0E0 Offset: 0xBFC4E0 VA: 0x180BFD0E0
	public static Vector3 OODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, bool flag) { }

	// RVA: 0xBFF610 Offset: 0xBFEA10 VA: 0x180BFF610
	public static float OQDDCCCOQD(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p) { }

	// RVA: 0xBFF4B0 Offset: 0xBFE8B0 VA: 0x180BFF4B0
	public static bool OQCDCDOOCD(Vector3 pTarget, Vector3 pSource, Vector3 pCheck) { }

	// RVA: 0xBFFE10 Offset: 0xBFF210 VA: 0x180BFFE10
	public static Vector3 OQQCQOCCOQ(Vector3 vA, Vector3 vB, Vector3 vPoint) { }

	// RVA: 0xBFF730 Offset: 0xBFEB30 VA: 0x180BFF730
	public static Vector3 OQDDDODCOC(Vector3 point, Vector3 pivot, Quaternion angle) { }

	// RVA: 0xBFA8D0 Offset: 0xBF9CD0 VA: 0x180BFA8D0
	public static float GetYAngleByDir(Vector3 dir) { }

	// RVA: 0xBFBCE0 Offset: 0xBFB0E0 VA: 0x180BFBCE0
	public static Vector3 OCOOCOOODQ(Vector3 point, float angle, Vector3 axis) { }

	// RVA: 0xC00050 Offset: 0xBFF450 VA: 0x180C00050
	public static Vector3 OQQDCOCCCO(Vector3 source, float angle) { }

	// RVA: 0xBFCD40 Offset: 0xBFC140 VA: 0x180BFCD40
	public static int ODOCOCDQCO(List<Material> mats, Material mat) { }

	// RVA: 0xBFB870 Offset: 0xBFAC70 VA: 0x180BFB870
	public static float OCCQDCCCOD(Vector3 fwd, Vector3 targetDir, Vector3 up) { }

	// RVA: 0xBFF9C0 Offset: 0xBFEDC0 VA: 0x180BFF9C0
	public static bool OQOQCCCODC(GameObject go, ref Bounds bounds) { }

	// RVA: 0xBFCEB0 Offset: 0xBFC2B0 VA: 0x180BFCEB0
	public static float OOCQOOCOQC(Vector3 pos, ERModularBase scr) { }

	// RVA: 0xBFC8B0 Offset: 0xBFBCB0 VA: 0x180BFC8B0
	public static Vector3 ODCCDOCDQD(Vector3 pos, Vector3 dir) { }

	// RVA: 0xBFB020 Offset: 0xBFA420 VA: 0x180BFB020
	public static Vector3 OCCDCCQDDO(Vector3 pos, Vector3 dir) { }

	// RVA: 0xBFDF70 Offset: 0xBFD370 VA: 0x180BFDF70
	public static Vector3 OOQODCCOQD(Vector3 pos, ERModularRoad scr) { }

	// RVA: 0xBFCE10 Offset: 0xBFC210 VA: 0x180BFCE10
	public static int ODQCDQOOCO(int segmentCount, SideObject so, bool newSegment, ERMesh mobject, bool lastSegment, bool skipStartBlend, bool skipEndBlend) { }

	// RVA: 0xBFB450 Offset: 0xBFA850 VA: 0x180BFB450
	public static void OCCQCDQQOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xBFF890 Offset: 0xBFEC90 VA: 0x180BFF890
	public static void OQODQODDOQ(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, float angle, Vector3 randomRotation) { }

	// RVA: 0xC00F10 Offset: 0xC00310 VA: 0x180C00F10
	public static void RandomAlignment(ref Vector3 v2, ref Vector3 n, Vector3 v, Vector3 dir, Vector2 vec, Vector3 randomRotation) { }

	// RVA: 0xBFB1B0 Offset: 0xBFA5B0 VA: 0x180BFB1B0
	public static void OCCDCDCQQQ(GameObject go, Vector3 v, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC00A00 Offset: 0xBFFE00 VA: 0x180C00A00
	public static void OQQOODCODQ(GameObject go, Vector3 v1, Vector3 v3, Vector3 dir, Vector3 randomRotation) { }

	// RVA: 0xBFC090 Offset: 0xBFB490 VA: 0x180BFC090
	public static void OCOQCDDODO(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation, Vector3 cp2, Vector3 cp3) { }

	// RVA: 0xBFA9D0 Offset: 0xBF9DD0 VA: 0x180BFA9D0
	public static void InstantiatedRandomRotation(GameObject go, Vector3 v1, ERModularRoad roadScr, Vector3 randomRotation) { }

	// RVA: 0xC01080 Offset: 0xC00480 VA: 0x180C01080
	public static bool RayTriangleOODOQDOODO(Vector3 p1, Vector3 p2, Vector3 p3, Ray ray) { }

	// RVA: 0xBFB970 Offset: 0xBFAD70 VA: 0x180BFB970
	public static void OCDODCQDDO(ERModularBase scr, Vector3 v1, Vector3 v2, ref float minY, ref float maxY) { }

	// RVA: 0xBF99A0 Offset: 0xBF8DA0 VA: 0x180BF99A0
	public static List<Vector3> GetSoSplinePoints(ERModularRoad scr, List<float> sidewaysList, ref List<int> markerInts, ref List<float> tValues, ref List<float> markerDistances, ref List<Vector3> tmpMarkers) { }

	// RVA: 0xBFD320 Offset: 0xBFC720 VA: 0x180BFD320
	public static List<Vector3> OOODQCOOCC(List<Vector3> points, float tension, float incr) { }

	// RVA: 0xBFD610 Offset: 0xBFCA10 VA: 0x180BFD610
	public static List<Vector3> OOODQCOOCC(Vector3 p1, Vector3 p2, Vector3 p3, Vector3 p4, float incr) { }

	// RVA: 0xBF7F70 Offset: 0xBF7370 VA: 0x180BF7F70
	public static List<List<Vector2>> GetRoadShapeValues(List<float> tValues, List<float> markerDistances, List<List<Vector2>> nodeListValues, int startMarker, int endMarker, List<Vector2> roadShape, List<int> shapeTransitionTypes, bool closedTrack) { }

	// RVA: 0xBF91B0 Offset: 0xBF85B0 VA: 0x180BF91B0
	public static List<Vector3> GetSoMarkerPositionVecs(ERModularRoad scr, List<float> sidewaysList, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xBF7210 Offset: 0xBF6610 VA: 0x180BF7210
	public static void CheckGetSoMarkerPositionVecs(ERModularRoad scr, int marker, ref List<Vector3> soMarkerVecs, ref List<Vector3> soMarkerDir, ref List<int> soMarkerInt) { }

	// RVA: 0xC01920 Offset: 0xC00D20 VA: 0x180C01920
	public static void TerrainSmooth(Terrain terrain, ERModularRoad road, float size, int type, ref int smoothStep) { }

	// RVA: 0xBF77B0 Offset: 0xBF6BB0 VA: 0x180BF77B0
	public static bool CheckSmoothPoint(int x, int z, float sampleWidth, float sampleHeight, ERModularBase scr) { }

	// RVA: 0xC01750 Offset: 0xC00B50 VA: 0x180C01750
	private static float Smooth(int x, int y, TerrainData terrainInfo) { }

	// RVA: 0xC016B0 Offset: 0xC00AB0 VA: 0x180C016B0
	private static float Smooth1(float indent, float surrounding, float posY) { }

	// RVA: 0xBF7A30 Offset: 0xBF6E30 VA: 0x180BF7A30
	public static bool CompareVector2List(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBF76C0 Offset: 0xBF6AC0 VA: 0x180BF76C0
	public static string CheckMesh(GameObject go) { }

	// RVA: 0xBFC3D0 Offset: 0xBFB7D0 VA: 0x180BFC3D0
	public static void OCQOQODOCQ(Mesh m, MeshRenderer ren) { }

	// RVA: 0xBFBB10 Offset: 0xBFAF10 VA: 0x180BFBB10
	public static List<float> OCOCDCOQCD(List<Vector2> nodes) { }

	// RVA: 0xBFCB20 Offset: 0xBFBF20 VA: 0x180BFCB20
	public List<Vector2> ODCOCDCDQC(List<Vector3> vecs, float x) { }

	// RVA: 0xBF6E20 Offset: 0xBF6220 VA: 0x180BF6E20
	public static bool CheckConnectAngle(Vector3 r1, Vector3 p1, Vector3 p2) { }

	// RVA: 0xBFE190 Offset: 0xBFD590 VA: 0x180BFE190
	public static void OOQQCCOQOC(Transform parent, ref GameObject go, string name, List<Vector3> OCDCOCQQOO, Material mat, float OOCODCCCOQ, float OQQDDDQDOQ, float OCCOCCCODQ, float ODCCDDDODQ, float ODDQQCDDOD, float OCQCODCDCO, Vector2 OQCOCDQODQ, Vector2 ODDCOOCQCO, float uvRatio) { }

	// RVA: 0xBFA940 Offset: 0xBF9D40 VA: 0x180BFA940
	public static bool InIntArray(int v, List<int> arr) { }

	// RVA: 0xBFD7D0 Offset: 0xBFCBD0 VA: 0x180BFD7D0
	public static void OOQCCQCCCC(ERModularBase scr) { }

	// RVA: 0xC00160 Offset: 0xBFF560 VA: 0x180C00160
	public static OQQCCQCDQQ OQQOCDDDCC(ERModularRoad road, Vector3 pos, QDQDOOQQDQODD rt, int splineIndex) { }

	// RVA: 0xBF7C30 Offset: 0xBF7030 VA: 0x180BF7C30
	public static int GetEdgePositionByDistance(List<Vector3> splinePoints, float distance, int startSplinePoint) { }

	// RVA: 0xBFBDC0 Offset: 0xBFB1C0 VA: 0x180BFBDC0
	public static int OCOODQDDDO(List<Vector3> splinePoints, float distance, int startSplinePoint, ref Vector3 pos) { }

	// RVA: 0xBFA860 Offset: 0xBF9C60 VA: 0x180BFA860
	public static int GetSplinePointIndex(List<Vector3> splinePoints, float distance, int startIndex, int dir) { }

	// RVA: 0xC00DD0 Offset: 0xC001D0 VA: 0x180C00DD0
	public static float OQQOQODCCC(Terrain terrain, Vector3 p1, Vector3 p2) { }

	// RVA: 0xC01490 Offset: 0xC00890 VA: 0x180C01490
	public static bool RaycastRoadsSurfaces(int layer, Vector3 pos, ref Vector2 uv, ref GameObject go, bool checkHeightFlag) { }

	// RVA: 0xBF7DA0 Offset: 0xBF71A0 VA: 0x180BF7DA0
	public static void GetIndexAndFraction(List<Vector3> points, float fraction, int index, float dist, ref int targetIndex, ref float targetFraction, int dir) { }

	// RVA: 0xBFCA40 Offset: 0xBFBE40 VA: 0x180BFCA40
	public static ERPoint ODCDDDCCDD(ERPoint source) { }

	// RVA: 0xBFAA70 Offset: 0xBF9E70 VA: 0x180BFAA70
	public static void MergeVertices(Mesh m) { }

	// RVA: 0xC02B90 Offset: 0xC01F90 VA: 0x180C02B90
	public static int in_array(List<Vector3> vecs, List<Color> colors, Vector3 v, Color c) { }

	// RVA: 0xC02AC0 Offset: 0xC01EC0 VA: 0x180C02AC0
	public static bool Vector2ListComparer(List<Vector2> list1, List<Vector2> list2) { }

	// RVA: 0xBF7B60 Offset: 0xBF6F60 VA: 0x180BF7B60
	public static bool FloatListComparer(List<float> list1, List<float> list2) { }

	// RVA: 0x2F91F0 Offset: 0x2F85F0 VA: 0x1802F91F0
	public void .ctor() { }

}

